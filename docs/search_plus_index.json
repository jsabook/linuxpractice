{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-05 10:55:05 "},"文件管理/ls.html":{"url":"文件管理/ls.html","title":"Ls","keywords":"","body":"ls命令 ls 一次性查看多个目录，要在文件夹中间加入两个空格 ls / /root ls -l 显示文件的长格式 ls -h 大小以M 或者G的形式显示 ls -a 查看所有文件（包括隐藏文件） ls -r 辅助ls -l，结合成ls -l -r 逆向输出 按照时间逆向输出ls -l -r -t,可以合并成ls -lrt ls -R 递归显示 cd 命令 cd 进入绝对路径 cd / cd 进入当前相对路径cd ./ cd 进入 上一层相对路径`cd ../.. Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-09-20 08:48:07 "},"文件管理/创建和删除目录.html":{"url":"文件管理/创建和删除目录.html","title":"创建和删除目录","keywords":"","body":"mkdir 创建多个文件夹，后面接多个文件夹位置 rmdir 删除文件夹，但是只能删除非空目录 rm 删除 rm -r 删除文件夹 rm -rf 不进行提示删除 touch 创建文件 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-09-20 08:22:12 "},"文件管理/打包压缩.html":{"url":"文件管理/打包压缩.html","title":"打包压缩","keywords":"","body":"linux 备份压缩，需要先打包再压缩 打包 tar 压缩gzip、bzip2 使用的扩展名 tar.gz tar.bz2 tar tar cf /dir/backup.tar /etc f 指定操作类型为文件 c 进行打包 tar czf /dir/backup.tar.gz /etc 使用gzip进行直接打包压缩（压缩速度更快） tar cjf /dir/backup.tar.bz2 /etc 使用bzip2进行直接打包压缩我们一般都是用bzip2进行压缩 tar xf /tmp/backup.tar -C /root` 解包 解压缩 zxf 对gzip进行解压缩 zjf 对bzip2 进行解压缩 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-09-20 08:55:43 "},"文件管理/查看文件.html":{"url":"文件管理/查看文件.html","title":"查看文件","keywords":"","body":"cat head head -num查看前num行文字 tail 查看结尾 tail -f 实施追踪文件的修改信息 wc 统计文件内容信息 wc -l 查看当前文件有几行 more 分行显示 less 分行显示 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 16:30:51 "},"用户管理/su与sudo的区别.html":{"url":"用户管理/su与sudo的区别.html","title":"su与sudo的区别","keywords":"","body":"visudo命令，将特殊命令赋值给一般用户 用户直接就写username即可，如果是用户组，则需要在前面添加百分号。%users。 all代表登陆终端，如果是本地的话就可以写成localhost。 用户配置文件 /etc/passwd 中文含义 用户名:密码:UID（用户ID）:GID（组ID）:描述性信息:主目录:默认Shell 其中的x，代表该用户需要密码登陆。 第一个1001代表用户的uid 第二个1001代表用户的groupid /etc/shadow 九个字段含义解释: 用户名 同 /etc/passwd 文件的用户名有相同的含义。 加密密码 这里保存的是真正加密的密码。目前 Linux 的密码采用的是 SHA512 散列加密算法，原来采用的是 MD5 或 DES 加密算法。SHA512 散列加密算法的加密等级更高，也更加安全。 注意，这串密码产生的乱码不能手工修改，如果手工修改，系统将无法识别密码，导致密码失效。很多软件透过这个功能，在密码串前加上 \"!\"、\"*\" 或 \"x\" 使密码暂时失效。 所有伪用户的密码都是 \"!!\" 或 \"*\"，代表没有密码是不能登录的。当然，新创建的用户如果不设定密码，那么它的密码项也是 \"!!\"，代表这个用户没有密码，不能登录。 最后一次修改时间 此字段表示最后一次修改密码的时间，可是，为什么 root 用户显示的是 15775 呢？ 这是因为，Linux 计算日期的时间是以 1970 年 1 月 1 日作为 1 不断累加得到的时间，到 1971 年 1 月 1 日，则为 366 天。这里显示 15775 天，也就是说，此 root 账号在 1970 年 1 月 1 日之后的第 15775 天修改的 root 用户密码。 那么，到底 15775 代表的是哪一天呢？可以使用如下命令进行换算： [root@localhost ~]# date -d \"1970-01-01 15775 days\" 2013年03月11日 星期一 00:00:00 CST 可以看到，通过以上命令，即可将其换算为我们习惯的系统日期。 最小修改时间间隔 最小修改间隔时间，也就是说，该字段规定了从第 3 字段（最后一次修改密码的日期）起，多长时间之内不能修改密码。如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 天之内不能再次修改密码。 此字段是为了针对某些人频繁更改账户密码而设计的。 密码有效期 经常变更密码是个好习惯，为了强制要求用户变更密码，这个字段可以指定距离第 3 字段（最后一次更改密码）多长时间内需要再次变更密码，否则该账户密码进行过期阶段。 该字段的默认值为 99999，也就是 273 年，可认为是永久生效。如果改为 90，则表示密码被修改 90 天之后必须再次修改，否则该用户即将过期。管理服务器时，通过这个字段强制用户定期修改密码。 密码需要变更前的警告天数 与第 5 字段相比较，当账户密码有效期快到时，系统会发出警告信息给此账户，提醒用户 \"再过 n 天你的密码就要过期了，请尽快重新设置你的密码！\"。 该字段的默认值是 7，也就是说，距离密码有效期的第 7 天开始，每次登录系统都会向该账户发出 \"修改密码\" 的警告信息。 密码过期后的宽限天数 也称为“口令失效日”，简单理解就是，在密码过期后，用户如果还是没有修改密码，则在此字段规定的宽限天数内，用户还是可以登录系统的；如果过了宽限天数，系统将不再让此账户登陆，也不会提示账户过期，是完全禁用。 比如说，此字段规定的宽限天数是 10，则代表密码过期 10 天后失效；如果是 0，则代表密码过期后立即失效；如果是 -1，则代表密码永远不会失效。 账号失效时间 同第 3 个字段一样，使用自 1970 年 1 月 1 日以来的总天数作为账户的失效时间。该字段表示，账号在此字段规定的时间之外，不论你的密码是否过期，都将无法使用！ 该字段通常被使用在具有收费服务的系统中。 /etc/group组的相关信息 最后一个字段，是其他组。代表这个组中的某些用户还属于其他组。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-10 23:14:37 "},"用户管理/文件与文件目录.html":{"url":"用户管理/文件与文件目录.html","title":"文件与文件目录","keywords":"","body":"文件权限 不同文件类型，linux不是以扩展名进行区分，而是以文件类型进行区分， 符号 含义 - 普通文件 d 目录文件 b 块特殊文件,指的是设备，比如插上u盘，那么u盘就是一个块设备 c 字符特殊文件 l 符号链接 f 命名管道 s 套间字文件 ​ 字符与数字的关系 rwx =111, r=100，是4 w=010,是2 xx=001,是1 文件夹权限的表示方式 字符 含义 x 进入目录 rx 显示目录下的文件名 wx 修改目录下的文件名 修改文件用户权限 chmod 修改文件、目录权限 chmod u+x /dir chmod 755 /dir chown 更改属主、属组。 修改属主 chown newuser dir 修改属组 chown :newgroup dir 修改文件权限 chmod 通过加减进行权限控制。 chmod u 代表属主；chmod g 代表属组；chmod o 代表其他；chmod a 代表所有； 字符 含义 `chmod u+x 给属主文件加上执行的权限 `chmod u=x 属主文件只有执行的权限 `chmod u-x 属主文件去掉执行的权限 更简便的方式——通过数字 chmod 446 file 将446权限赋值给file用户。 权限管理 当权限发送冲突时候，以属主为准，如下图： user1 对bfile没有任何权限，但是group1有可删除权限，那么就是属主原则，没有任何权限 文件夹目录 x表示进入目录 r表示读取文件夹内的子文件 下面两张图是相反的两张图 w表示在文件夹内创建和删除子文件的权限 x表示在文件夹内 特殊的权限 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-10-11 00:05:45 "},"用户管理/用户和用户组.html":{"url":"用户管理/用户和用户组.html","title":"用户和用户组","keywords":"","body":"用户新建 useradd id username 查看 username是否在用户表中 用户相关配置文件 /etc/passwd，用户文件 /etc/shadow，用户密码文件 如果创建的时候没有指定组，就会单独创建一个同名的组 passwd username，为username指定密码。 用户删除 userdel username删除用户 做的操作 /etc/passwd中删除相关用户 /etc/shadow中删除相关密码 home目录的id变为1000 userdel -r username删除用户的同时删除该用户的家目录 修改用户属性 usermod -d /dir username修改该用户的默认家目录 usermod -g group username修改该用户的默认组 change修改用户的生命周期 切换用户 ​ su username 不完全切换 su - username 完全切换，切换的同时，切换到家目录 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-09-28 01:53:00 "},"磁盘管理/01磁盘.html":{"url":"磁盘管理/01磁盘.html","title":"01磁盘","keywords":"","body":"文件系统 本篇文章介绍linux使用最广泛的文件系统——ext4 ext4包括四部分 超级块，在ext4文件系统开始的部分，记录分区包含了多少个文件， 超级块副本，对超级块进行备份，恢复数据，就可以通过恢复超级块进行恢复数据。因为数据块的内容并没有被覆盖掉。 i节点，记录每个文件，文件的名称和大小，文件的编号和权限。但是文件名和编号并没有放在同一个i节点里面。文件点是放在文件的父亲i节点里面。 数据块，记录数据。同个文件可以划分成多个数据块，挂载到同一个i节点中。 通过i节点，这个概念。也可以明白了为什么mv的时候会这么快，mv改名只是改动了i节点中的文件名。 所以，如果i节点发生了变化，那么该文件就不是原文件了。 vim操作的话，是vim打开一个文件的时候会创建一个swp版本的文件。我们其实是对这个进行操作，操作完以后，会将swp文件命名为原来的文件名，这样子也就是为什么vim操作以后i节点会发生改变。 所以删除文件，其实是将i节点与文件名断开，只要找到i节点，那么就能恢复文件。防止误删的一个操作就是通过ln命令进行硬连接，从而使得两个文件名指向同一个i节点。这样子的话，这两个文件名是等同的。 所以ln是不能跨越分区的。 ln filea fileb # 为fileb创建硬链接filea ln -s filea fileb # 为fileb创建软链接filea，其实就是创建一个快捷方式 ext4文件访问控制列表 ext4独有，可以单独设置一个用户的读写权限。 查看某个文件的访问控制列表 getfacl afile 赋予权限 setfacl -m u:user1:r afile # 为user1用户组赋予读的权限 setfacl -m g:group1:rw afile # 为group1用户组赋予读和写的权限 RAID 磁盘阵列 raid级别 含义 raid 0 一个数据拆成两份，一份数据拆成两份，存到两个地方，提高200%的读取速度 raid 1 镜像方式 ，一份数据会自动备份到第二块磁盘，提高200%的可靠性，但是两块磁盘里面，只有一块磁盘可以用。 raid 5 至少有三块硬盘，两块存数据，第三块存校验值。 raid 10 0和1的组合 四块硬盘 两块做raid1 两块做raid1 .两块做了raid1的磁盘拿出来做raid0 通过硬件设备完成，通过raid控制器来进行raid操作。 软件raid，cpu开销非常大。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-04 16:27:33 "},"磁盘管理/02查看磁盘.html":{"url":"磁盘管理/02查看磁盘.html","title":"02查看磁盘","keywords":"","body":"磁盘内容查看 fdisk fdisk -l boot 系统启动 逻辑卷——centos-root 扇区查看 parted 这个命令，主要就是用来查看分区的 df df 关注点就是文件分区与挂载分区之间的关系 lsblk 查看分区与挂载点 小结 命令 特点 fdisk 最全，但是信息也最多 df 分区的使用情况 lsblk 查看块的分区情况 文件大小查看 du 实际占用的空间 du 比ls 查看出来的结果更小 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-04 16:48:38 "},"磁盘管理/03挂载磁盘.html":{"url":"磁盘管理/03挂载磁盘.html","title":"03挂载磁盘","keywords":"","body":"磁盘扩展 查看磁盘fdisk -l，可以下图中 可以看出，在/dev/sda这块磁盘中，存在三块分区，sda1,sda2,sda3.而sda这块磁盘中还存在一部分磁盘空间没有进行分区，那么现在就开始对sda剩下的磁盘空间进行分区 划分磁盘分区 使用命令fdisk /dev/sda root@phpmywind:~# fdisk /dev/sda # 进入该磁盘，准备分区 Welcome to fdisk (util-linux 2.31.1). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. GPT PMBR size mismatch (83886079 != 104857599) will be corrected by w(rite). GPT PMBR size mismatch (83886079 != 104857599) will be corrected by w(rite). Command (m for help): n # 选择n选项，代表进行风区 Partition number (4-128, default 4): 4 # 分区号，和前面的sda1、sda2、sda3一样 First sector (63886047-104857566, default 63887360): 63887360 # sda3这块分区开始的块地址 Last sector, +sectors or +size{K,M,G,T,P} (63887360-104857566, default 104857566):#sda3块结束地址 Created a new partition 4 of type 'Linux filesystem' and of size 19.5 GiB. Command (m for help): w # 代表将前面的操作都写入执行，然后退出。 GPT PMBR size mismatch (83886079 != 104857599) will be corrected by w(rite). The partition table has been altered. Syncing disks. root@phpmywind:~# 查看分区出来的结果 发现sda4已经分离出来了，但是没有部署文件系统。 设置文件系统 使用命令mkfs.ext4 磁盘分区，等待几秒即可，如果磁盘分区比较大，那么花费的时间也就会比较长。 root@phpmywind:~# mkfs.ext4 /dev/sda4 mke2fs 1.44.1 (24-Mar-2018) Creating filesystem with 5121275 4k blocks and 1281120 inodes Filesystem UUID: 455e41a2-2b6d-4ab7-9722-48199d366506 Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 4096000 Allocating group tables: done Writing inode tables: done Creating journal (32768 blocks): done Writing superblocks and filesystem accounting information: done root@phpmywind:~# 分好后，查看，发现已经设置成功 挂载目录 将磁盘分区挂载到响应的目录下 手动挂载 即每次开机不能自动挂载都要手动挂载 mount -t ext4 -o rw /dev/sdb4 /home/wujiashuai 就是这行命令，解释一下就是将/dev/sdb4挂载到/home/wujiashuai下 自动挂载 即每次开机后能够自动挂载，即修改/etc/fstab这个文件 首先获取对应的磁盘分区的uuid，注意这里是查看/dev目录下。 root@phpmywind:~# blkid /dev/sda4 /dev/sda4: UUID=\"455e41a2-2b6d-4ab7-9722-48199d366506\" TYPE=\"ext4\" PARTUUID=\"7f6f1703-7eb3-7348-adb0-56c5c2a5548b\" 修改/etc/fstab文件，将一行语句写入 第一个0的意思，不要进行dump备份 第二个0的意思，不要进行磁盘检查 结束编辑后，使用mount -a进行刷新即可。 这里既是刷新，也是检查配置文件有没有写错。如果写错则会进行报错 一定要没有错了，才可以。不然关机后，会启动不了，最后只能修改启动界面，才能修改回来。 磁盘挂载 磁盘挂载与磁盘扩展基本上是一样的 下面对/dev/sdc进行磁盘挂载 磁盘分区 root@phpmywind:~# fdisk /dev/sdc Welcome to fdisk (util-linux 2.31.1). Changes will remain in memory only, until you decide to write them. Be careful before using the write command. Device does not contain a recognized partition table. Created a new DOS disklabel with disk identifier 0xe8c8ae93. Command (m for help): n Partition type p primary (0 primary, 0 extended, 4 free) e extended (container for logical partitions) Select (default p): Using default response p. Partition number (1-4, default 1): First sector (2048-20971519, default 2048): Last sector, +sectors or +size{K,M,G,T,P} (2048-20971519, default 20971519): Created a new partition 1 of type 'Linux' and of size 10 GiB. 磁盘系统设置 root@phpmywind:~# mkfs.ext4 /dev/sdc1 mke2fs 1.44.1 (24-Mar-2018) Creating filesystem with 2621184 4k blocks and 655360 inodes Filesystem UUID: fd5f67fa-021f-42c2-ba0f-cfddbeeebff5 Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632 Allocating group tables: done Writing inode tables: done Creating journal (16384 blocks): done Writing superblocks and filesystem accounting information: done root@phpmywind:~# 挂载磁盘,并且检查磁盘挂载情况 root@phpmywind:~# mount -t ext4 -o rw /dev/sdc1 /home/mounttest root@phpmywind:~# lsblk -f NAME FSTYPE LABEL UUID MOUNTPOINT loop0 squashfs /snap/core/8039 loop1 squashfs /snap/core/8268 sda ├─sda1 ├─sda2 ext4 2747fc02-65e8-43ca-afd4-4470a388f990 / ├─sda3 ext4 367122f3-65b6-43f6-9fee-a409dcb33865 /mnt/gitlab └─sda4 ext4 455e41a2-2b6d-4ab7-9722-48199d366506 sdb sdc └─sdc1 ext4 fd5f67fa-021f-42c2-ba0f-cfddbeeebff5 /home/mounttest sr0 iso9660 Ubuntu-Server 18.04.3 LTS amd64 2019-08-05-20-00-00-00 /media/root/Ubuntu root@phpmywind:~# Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-04 16:13:32 "},"磁盘管理/04逻辑盘扩展.html":{"url":"磁盘管理/04逻辑盘扩展.html","title":"04逻辑盘扩展","keywords":"","body":"逻辑卷LVM管理 一个物理设备就是一个物理卷、也就是一块硬盘也就是一个物理卷。 逻辑卷使用起来比物理卷更加灵活。由于系统是放在逻辑卷上的，因此可以通过扩展逻辑卷，从而可以实现不关机扩展卷。 逻辑卷是将几个物理卷圈到一起，将多个大小不通的物理卷（硬盘）拼接到一起，拼接成逻辑组。然后按照需要进行切割成逻辑卷 创建流程 创建物理卷(physical volume) pv操作 [root@localhost ~]# pvcreate /dev/sdb /dev/sdc /dev/sdd Physical volume \"/dev/sdb\" successfully created. Physical volume \"/dev/sdc\" successfully created. Physical volume \"/dev/sdd\" successfully created. 查看物理卷 [root@localhost ~]# pvs PV VG Fmt Attr PSize PFree /dev/sda2 centos lvm2 a-- 可以看到有一个逻辑组centos，新的三个物理卷没有所属的逻辑组。 创建卷组(volume group) 为新增加的三个物理卷创建所属的卷组 [root@localhost ~]# vgcreate vg1 /dev/sdb /dev/sdc /dev/sdd Volume group \"vg1\" successfully created 查看卷组 [root@localhost ~]# vgs VG #PV #LV #SN Attr VSize VFree centos 1 2 0 wz--n- 其中pv，是这个逻辑组有几个物理卷。lv则是这个逻辑组有几个逻辑卷。 一个pv不能加入到两个卷组。 创建逻辑卷(logical volume) 创建好逻辑组之后，就需要对逻辑组进行切割，切割出逻辑卷进行使用。 [root@localhost ~]# lvcreate -L 100M -n lv1 vg1 Logical volume \"lv1\" created. -L指的是逻辑卷大小 -n 逻辑卷的名称 lvcreate -L 逻辑卷大小 -n 逻辑卷名称 卷组 查看效果 [root@localhost ~]# lvs LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert root centos -wi-ao---- 36.99g swap centos -wi-ao---- 2.00g lv1 vg1 -wi-a----- 100.00m 使用逻辑卷 将lv1看成一个分区即可。 [root@localhost ~]# mkfs.ext4 /dev/vg1/lv1 mke2fs 1.42.9 (28-Dec-2013) 文件系统标签= OS type: Linux 块大小=1024 (log=0) 分块大小=1024 (log=0) Stride=0 blocks, Stripe width=0 blocks 25688 inodes, 102400 blocks 5120 blocks (5.00%) reserved for the super user 第一个数据块=1 Maximum filesystem blocks=33685504 13 block groups 8192 blocks per group, 8192 fragments per group 1976 inodes per group Superblock backups stored on blocks: 8193, 24577, 40961, 57345, 73729 Allocating group tables: 完成 正在写入inode表: 完成 Creating journal (4096 blocks): 完成 Writing superblocks and filesystem accounting information: 完成 [root@localhost ~]# mkdir /mnt/test [root@localhost ~]# mount -t ext4 -o rw /dev/vg1/lv1 /mnt/test/ 扩展系统盘 扩展系统盘，其实也就是扩展逻辑卷。因为是扩充逻辑卷 扩展卷组 因为卷组中没有空间了，所以需要先将物理卷扩展到逻辑组中。 [root@localhost ~]# vgextend centos /dev/sdd Volume group \"centos\" successfully extended 扩展逻辑卷 [root@localhost ~]# lvextend -L +2G /dev/centos/root Size of logical volume centos/root changed from 36.99 GiB (9470 extents) to 38.99 GiB (9982 extents). Logical volume centos/root successfully resized. 查看扩展情况 [root@localhost ~]# lvs LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy%Sync Convert root centos -wi-ao---- 38.99g 已经增加了2G。 刷新系统文件系统 如果是ext4文件系统那么是不需要进行查看。如果是xfs文件系统，是需要进行刷新的。 xfs_grows /dev/centos/root 即xfs_grows 逻辑卷名称 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-04 17:57:43 "},"磁盘管理/05交换分区.html":{"url":"磁盘管理/05交换分区.html","title":"05交换分区","keywords":"","body":"交换分区的查看与创建 交换分区就是虚拟内存，交换分区会在内存资源全部被占用后，启用充当内存的作用。 交换分区的创建 增加交换分区的大小 向挂载普通磁盘一样，进行操作 分区创建swap [root@localhost ~]# fdisk /dev/sdb 欢迎使用 fdisk (util-linux 2.23.2)。 更改将停留在内存中，直到您决定将更改写入磁盘。 使用写入命令前请三思。 命令(输入 m 获取帮助)：n Partition type: p primary (0 primary, 0 extended, 4 free) e extended Select (default p): Using default response p 分区号 (1-4，默认 1)：1\\ 分区号 (1-4，默认 1)： 起始 扇区 (2048-10485759，默认为 2048)： 将使用默认值 2048 Last 扇区, +扇区 or +size{K,M,G} (2048-10485759，默认为 10485759)：+1G 分区 1 已设置为 Linux 类型，大小设为 1 GiB 命令(输入 m 获取帮助)：w The partition table has been altered! Calling ioctl() to re-read partition table. 正在同步磁盘。 为分区安装swap“文件系统” [root@localhost ~]# mkswap /dev/sdb1 mkswap: /dev/sdb1: warning: wiping old ext4 signature. 正在设置交换空间版本 1，大小 = 1048572 KiB 无标签，UUID=e896cdd8-2aaa-418e-933d-995c2c184439 打开swap [root@localhost ~]# free -m total used free shared buff/cache available Mem: 972 186 664 7 121 651 Swap: 3071 0 3071 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-04 18:04:11 "},"SHELL/00交互.html":{"url":"SHELL/00交互.html","title":"00交互","keywords":"","body":"如果在运行过程中，需要与用户进行交互，这个是通过read这个shell命令的 [root@localhost demosh]# cat read.sh #!/bin/bash while true do read code echo $code done [root@localhost demosh]# bash read.sh this is a test this is a test 1 1 23 23 3432423 3432423 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 15:07:27 "},"SHELL/06shell函数.html":{"url":"SHELL/06shell函数.html","title":"06shell函数","keywords":"","body":"函数的定义 自定义函数 function fname(){ shell command1 shell command2 } 函数的执行 fname 第二种定义方式 fname(){ shell command1 shell command2 } 直接将function省掉 函数的参数 如果想要给函数增加参数 函数作用范围的变量 local 变量名 函数的参数 $1 $2 $3 ... $n [root@localhost mp3dir]# cdls(){ > cd $1 > ls > } [root@localhost demosh]# cdls /tmp 10.sh systemd-private-752912361d68446a9ffd69740493b6fc-chronyd.service-mGqMXt systemd-private-b472b6c8990f4b4298a5a457a6d186bb-chronyd.service-tfliIr vmware-root_658-2697598381 vmware-root_666-2731021219 vmware-root_678-2722697728 [root@localhost tmp]# cdls /home/ test test1 test122 test2 test22 user1 user2 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 16:51:20 "},"SHELL/07系统函数.html":{"url":"SHELL/07系统函数.html","title":"07系统函数","keywords":"","body":"系统自建了函数库，可以在脚本中引用。 /etc/init.d/functions这个文件就是系统函数 自建函数库 使用source函数脚本导入函数 [root@localhost demosh]# cat infunc.sh source /etc/init.d/functions echo_success [root@localhost demosh]# bash infunc.sh [root@localhost demosh]# [ 确定 ] Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 15:24:21 "},"SHELL/08脚本控制.html":{"url":"SHELL/08脚本控制.html","title":"08脚本控制","keywords":"","body":"脚本优先级控制 指的是脚本资源占用的分配，可以使用nice和renice调整脚本优先级 避免出现不可控的死循环 捕获信号 捕获信号脚本的编写 kill 默认 会发送15号信号给应用程序 ctrl+c发送2信号给应用程序 9号信号不可堵塞 捕获到信号之后可以执行一些命令。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 16:29:10 "},"SHELL/09定时脚本.html":{"url":"SHELL/09定时脚本.html","title":"09定时脚本","keywords":"","body":"如何防止二次运行 查看/etc/cron [root@localhost ~]# cat /etc/cron.d/0hourly # Run the hourly jobs SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root 01 * * * * root run-parts /etc/cron.hourly run-parts 脚本作用就是执行每一条cron指令，并且给每一个任务增加一个flag。从而防止一个记录执行多遍。 crontab命令 执行命令 增加一条crontab crontab -e 内容 # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * command to be executed 0 0 1 * * echo `date` 每个月1号0点0分 执行一条 echo `data` root用户为其他用户指定定时任务 crontab -u user -e 其他参数 -l 列出一个用户的定时任务 -r (delete user's crontab) -i (prompt before deleting user's crontab) -s (selinux context) 内容保存在/var/spool/目录下 root@localhost cron]# crontab -u user2 -e no crontab for user2 - using an empty one crontab: installing new crontab [root@localhost cron]# ls user1 user2 [root@localhost cron]# cat user2 0 0 1 * * echo `data` [root@localhost cron]# crontab文件 [root@localhost etc]# cat crontab SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # For details see man 4 crontabs # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed */1 * * * * root echo `data` crontab文件和crontab -e命令区别 格式不同 前者比后者多了一个用户，而这样子也有了好处，那就是root用户可以统一管理每个用户的cron 使用范围 修改/etc/crontab这种方法只有root用户能用，这种方法更加方便与直接直接给其他用户设置计划任务，而且还可以指定执行shell等等， crontab -e这种所有用户都可以使用，普通用户也只能为自己设置计划任务。然后自动写入/var/spool/cron/usename。 crontab -e 是针对用户的cron来设计的，如果是系统的例行性任务，该怎么办？是否还是需要以crontab -e来管理例行性命令？当然不需要，您只需要编辑/etc/crontab文件就可以了。需要注意的是：crontab -e的作用其实是/usr/bin/crontab这个执行文件，但是/etc/crontab是个纯文本文件，可以root的身份编辑这个文件。 语法检查 crontab 会进行语法检查 vi 不会 重启服务 基本上，cron服务的最低检测时间单位是分钟，所以cron会每分钟读取一次/etc/crontab与/var/spool/cron中的数据内容，因此，只要您编辑完/etc/crontab文件并且保存之后，crontab时设定就会自动执行。 ​ 注意：在linux下的crontab会自动帮我们每分钟重新读取一次/etc/crontab的例行工作事项，但是某些原因或在其他的unix系统中，由于crontab是读到内存中，所以在您修改完/etc/crontab之后可能并不会马上执行，这时请重新启动crond服务。 日志文件 开启日志文件 ubuntu系统需要开启日志文件 在 Ubuntu服务器上 查看定时任务的日志时，并没有在 /var/log/cron.log 文件。 看配置发现是默认没有开启 crontab 日志记录。 修改配置文件 sudo vim /etc/rsyslog.d/50-default.conf 取消 cron 行的注释 重启 系统日志服务 即可 sudo service rsyslog restart 查看日志文件 CentOS: tail -f /var/log/cron Ubuntu: tail -f /var/log/cron.log 这个日志文件中存储了crontab的日志信息 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 22:11:35 "},"SHELL/10为脚本加锁.html":{"url":"SHELL/10为脚本加锁.html","title":"10为脚本加锁","keywords":"","body":"排他锁 运行一个脚本只能运行一次。 flock -xn \"/tmp/f.lock\" -c \"/root/a.sh\" 查看运行结果 运行脚本第二次的时候，会发现锁文件还在被占用。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 16:22:55 "},"SHELL/使用循环判断位置参数.html":{"url":"SHELL/使用循环判断位置参数.html","title":"使用循环判断位置参数","keywords":"","body":"命令行参数 命令行参数，就是脚本后的跟着的参数 命令行参数可以使用$1 $2 $3...$n进行读取 $0代表的是脚本名称 $*和$@代表所有位置参数 $#代表位置参数的数目 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 14:36:28 "},"SHELL/判断语句case.html":{"url":"SHELL/判断语句case.html","title":"判断语句case","keywords":"","body":"脚本的参数 $0代表的是上一条语句执行是否成功，如果执行成功，那么$0=0 $1 代表的是执行该脚本的第一个参数，script.sh param1 param2 其中$1就是等于param1 其中$2就等于param2 [root@localhost ~]# cat casedemo.sh #!/bin/bash case \"$1\" in \"start\"|\"START\") echo $0 start... ;; \"stop\") echo $0 stop... ;; \"restart\"|\"reload\") echo $0 restart ;; *) echo Usage:$0 \"{start|stop}\" ;; esac [root@localhost ~]# bash casedemo.sh stop casedemo.sh stop... [root@localhost ~]# bash casedemo.sh start casedemo.sh start... [root@localhost ~]# bash casedemo.sh reload casedemo.sh restart Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 12:27:27 "},"SHELL/判断语句if.html":{"url":"SHELL/判断语句if.html","title":"判断语句if","keywords":"","body":"if-then if-then基本用法 + if [测试条件成立] 或者 命令返回值为0 + then 执行相应命令 + fi结束 []等于 tset 下面一个是个简单的if语句 [root@localhost ~]# if test $UID = 0 > then > echo \" root user \" > fi root user 等价于 [root@localhost ~]# if [ $UID = 0 ] > then > echo \" user root \" > fi user root 注意的是[]内左右必须要有两个空格。[ $UID = 0]与[$UID = 0 ]都是错误的[ $UID = 0 ]是正确的。 test 命令最短的定义可能是评估一个表达式；如果条件为真，则返回一个 0 值。如果表达式不为真，则返回一个大于 0 的值 — 也可以将其称为假值。 if-else [root@localhost ~]# cat ifelse.sh #!/bin/bash if [ $UID = 0 ] then echo \" root user \" else echo \" other user\" fi 输出 [root@localhost ~]# bash ifelse.sh root user if-elif [root@localhost ~]# cat ifelif.sh #!/bin/bash if [ $UID = root ] then echo \" root user \" elif [ $UID = user1 ] then echo \" user1 user\" else echo \" other user\" fi [root@localhost ~]# bash ifelif.sh other user 要点： 判断语句后面一定会跟上一个then，无论是if又或者是elif。 else后面可以直接跟上执行语句 嵌套if语句 [root@localhost ~]# bash ifinif.sh please run run 10.sh [root@localhost ~]# cat ifinif.sh #!/bin/bash if [ $UID = 0 ] then echo \" please run \" if [ -x /tmp/10.sh ] then /tmp/10.sh else chmod +x /tmp/10.sh /tmp/10.sh fi else echo \" switch user root \" fi Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-02 22:55:47 "},"SHELL/循环语句for.html":{"url":"SHELL/循环语句for.html","title":"循环语句for","keywords":"","body":"for循环 [root@localhost ~]# bash for.sh a is 1 a is 2 a is 3 a is 4 a is 5 a is 6 a is 7 a is 8 a is 9 [root@localhost ~]# cat for.sh for a in {1..9} do echo \"a is $a \" done 其中 for in后面更着的是一个列表 类似的还有下面这个例子 [root@localhost demosh]# bash for2.sh anaconda-ks.cfg casedemo.sh for2.sh for.sh ifelif.sh ifelse.sh ifinif.sh [root@localhost demosh]# cat for2.sh #!/bin/bash for filename in `ls *` do echo \"$filename\" done 使用for循环要点 列表中包含多个变量，变量使用空格分隔。 C语言风格的for循环 for((变量初始化；循环判断条件；变量变化步长)) do shell command done Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 14:26:14 "},"SHELL/循环语句while.html":{"url":"SHELL/循环语句while.html","title":"循环语句while","keywords":"","body":"写法 while test测试 do shell command done test测试 返回条件是否为0 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 14:31:35 "},"复制与移动目录.html":{"url":"复制与移动目录.html","title":"复制与移动目录","keywords":"","body":"cp cp -r 复制文件 cp -v 显示复制过程 cp -t 复制文件的最后修改时间 cp -a 复制文件的所有信息（包括文件的所有者与权限和时间）等价于 cp -dpR mv 移动文件与文件夹，重命名功能 改名 mv filea fileb 移动 mv ./dira/filea ./dirb/fileb 移动文件夹 /dirc /tmp 将dirc3文件夹移动到/tmp 目录下 通用符 一次性操作多个文件 * 匹配当前文件夹的所有文件 mv file*移动当前的所有以file开头的文件 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-03 17:33:16 "},"文本编辑器.html":{"url":"文本编辑器.html","title":"文本编辑器","keywords":"","body":"vim 正常模式 使用i进入插入模式 hjkl进行操作 | 指令 | 含义 | | ---- | ---- | |h |向左移动| |l|向右移动| |j|向下移动| |k|向上移动| 复制，y复制一行，numyy，复制num行数据，从当前光标复制到结尾y$ 剪切，dd剪切一行，numdd剪切num行，d$剪切当前光标到结尾。 粘贴,以上的粘贴和剪切的复制方式都是p 撤销上一步u，撤销多步，多按几次u 前滚,ctrl+R 单个字符删除命令，x，删除光标的指定字符。 替换字符，r 移动光标到指定的行数,num G(shift+g)。移动到100行的开头100 shift+g 光标移动到开头g，光标移动到结尾G 来到这一行的开头^(shift+6)，这一行的结尾$(shift+4) 命令模式 保存文件到指定目录 冒号后面可以接上命令，这样子可以不用推出可以直接查看相关性息。如:ifconfig ，查看ip地址，但并不退出修改文件。 查找命令 /查找的字符，查找下一个匹配的字符n，查找上一个匹配的字符N 替换命令 :s/old/new默认针对光标所在的一行 :%s/old/new 查找全文。 :%s/old/new/g替换多个字符，其中的g是全局操作。 :first,second%s/old/new/g,在first到second这两行之间进行全局替换。 显示行数:set nu vim的配置文件所在地，vim /etc/vimrc 可视模式 对文件进行大量的重复操作 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-09-28 01:36:41 "},"防火墙.html":{"url":"防火墙.html","title":"防火墙","keywords":"","body":"centos防火墙 是使用的iptables centos7 默认的防火墙是firewallD centos6 默认的防火墙是iptables iptables 表 filter 表 做过滤 nat表 做nat转发 将内网的ip地址转换为公网地址。 过滤链 对一条链 从外部进入内部的一条通道 从内部进入外部的一条通道 forward 转发通道 的入口、出口做控制。 Copyright © dsx2016.com 2019 all right reserved，powered by Gitbook该文章修订时间： 2020-11-04 18:13:48 "}}